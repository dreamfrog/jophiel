'''
Created on 2012-3-12

@author: lzz
'''

import time
import datetime
import logging
import json
import uuid

from jophiel.app import client
from jophiel.backend.base import BaseStat
from jophiel.backend import count
from jophiel.app import logger

logger = logging.getLogger(__name__)
       
"""
    information related to worker
    worker_id,every_worker has unique id that is assigned ,worker_id is generated by uuid
    so every worker enter this system will be assigned as a new worker node,will give service 
    until this worker exit,when the worker enter the system again ,will be asigned a new worker id ,s
    use expire time to keep monitor on key
    
    worker will store information related to infomation
    worker information:
        resque:workers
        resque:workers:processed
        resque:workers:failed
        
        resque:worker:worker_id
        resque:worker:worker_id:info
        resque:worker:worker_id:queues:
        resque:worker:worker_id:working
        resque:worker:worker_id:processed
        resque:worker:worker_id:failed
        resque:worker:worker_id:task
        
        expire resque:worker:worker_id to monitor worker_id
    
"""

class WorkerStats(BaseStat):
    resq_workers = "resque:workers"
    resq_processed = "resque:workers:processed"
    resq_failed = "resque:workers:failed"
    resq_worker_queues = "resque:worker:%s:queues"
    resq_worker_processed = "resque:worker:%s:processed"
    resq_worker_failed = "resque:worker:%s:failed"
    resq_worker_task = "resque:worker:%s:task"
    resq_worker_params = "resque:worker:%s:param"
    resq_worker_start = "resque:worker:%s:start"
    resq_worker = "resque:worker:%s"
    
    def __init__(self,worker_id, queue_name):
        self.queue_name = queue_name
        self.worker_id =worker_id
    
    @classmethod
    def all(cls):
        return [cls.find(w) for w in client.smembers(cls.resq_workers) or []]
    
    @classmethod
    def exists(cls,worker_id):
        if worker_id in client.smembers(cls.resq_workers):
            return True
        return False
        
    @classmethod
    def find(cls, worker_id):
        if cls.exists(worker_id):
            queues = client.get(cls.resq_worker_queues%worker_id)
            worker = cls(queues,worker_id)
            return worker
        else:
            return None
    
    @classmethod
    def get_processed(cls,worker_id):
        return count.Stats(cls.resq_worker_processed%worker_id ).get()

    def processed(self):
        return self.get_processed(self.worker_id)

    def process(self):
        count.Stats(self.resq_processed).incr()
        count.Stats(self.resq_worker_processed%self.worker_id).incr()
    
    @classmethod
    def get_failed(cls,worker_id):
        return count.Stats(cls.resq_worker_failed % worker_id).get()
    def failed(self):
        return self.get_failed(self.worker_id)   
    def fail(self):
        count.Stats(self.resq_failed).incr()
        count.Stats(self.resq_worker_failed%(self.worker_id)).incr()   

    def job(self):
        data = client.get(self.resq_worker_task%self.worker_id)
        if data:
            return json.loads(data)
        return {}


    def _set_started(self, dt):
        if dt:
            key = int(time.mktime(dt.timetuple()))
            client.set(self.resq_worker_start % self.worker_id, key)
        else:
            client.delete(self.resq_worker_start % self.worker_id)

    def _get_started(self):
        datestring = client.get(self.resq_worker_start % self.worker_id)
        return datestring

    started = property(_get_started, _set_started)
    
    def __str__(self):
        return "%s"%self.worker_id
    
    def register_worker(self):
        client.sadd(self.resq_workers, str(self))
        self.started = datetime.datetime.now()
        
    def unregister_worker(self):
        client.srem(self.resq_workers, str(self))
        self.started = None

    #workiong params
    def working_on(self, task):
        data = {}
        data = json.dumps(data)
        client[self.resq_worker_task%self.worker_id] = data
        
    def done_working(self):
        self.processed()
        client.delete(self.resq_worker_task % self.worker_id)

    def processing(self):
        return self.job()

    def state(self):
        stats = client.get(self.resq_worker%self.worker_id)
        if stats:
            return stats
        return None
    
    def expire(self,timeout = 120):
        client.expire(self.resq_worker%self.worker_id,timeout)
        
    def ttl(self):
        pass   
    