import pymongo
import hashlib;
import itertools;
import math;
meta_table="sysmeta"
def key_hash(key):
	m=hashlib.md5(key).hexdigest();
	return int(m,16);
	#r=0;
	#for i in m:
	#	r+=ord(i)+ord(i) ^27;
	#return r;
class Connection:
	default_prefix="chunk_";
	def __init__(self,host,port,tname,create=False,split_size=None,user=None,pwd=None,pre=None,**arg):
		self.host=host;
		self.port=port;
		self.tname=tname;
		self.hashsize=split_size;
		self.conn=pymongo.Connection(host,port,**arg);
		self.prefix=self.default_prefix;
		if pre:
			self.prefix=pre;
		if create and (not split_size) and split_size<0:
			raise "parameter Wrong"; 
		if create:
			if user:
				self.conn["admin"].authenticate(user,pwd); 
			try:
				self.conn[tname].create_collection(meta_table);
				self.conn[tname][meta_table].insert({"hashsize":split_size,"prefix":self.prefix,"id":1});
			except:
				#raise "%s already exists!" % tname;		
				pass;
			#self.conn[tname][meta_table].insert({"hashsize":split_size,"prefix":self.prefix,"id":1});
		if user:
			self.authenticate(user,pwd);
		info=self.conn[tname][meta_table].find_one({"id":1});
		self.hashsize=info["hashsize"];
		self.prefix=info["prefix"];
		
	def authenticate(self,user,name):
		ret=self.conn[self.tname].authenticate(user,name);
		if not ret:
			return self.conn["admin"].authenticate(user,name);

	def __getitem__(self,name):
		return self.conn[self.tname][name]

	def getChunkConn (self,key):
		s=key_hash(key)%self.hashsize
		chunk_name=self.prefix+str(s)
		return self.conn[self.tname][chunk_name]
	def getChunkName (self,key):
		s=key_hash(key)%self.hashsize
		chunk_name=self.prefix+str(s)
		return chunk_name

	def insert(self,key,*targ,**karg):
		s=key_hash(key)%self.hashsize;
		chunk_name=self.prefix+str(s);
		return self.conn[self.tname][chunk_name].insert(*targ,**karg);
	def find(self,key,*targ,**karg):
		s=key_hash(key)%self.hashsize;
		chunk_name=self.prefix+str(s);
		return self.conn[self.tname][chunk_name].find(*targ,**karg);
	def find_one(self,key,*targ,**karg):
		s=key_hash(key)%self.hashsize;
		chunk_name=self.prefix+str(s);
		return self.conn[self.tname][chunk_name].find_one(*targ,**karg);
	def findAll(self,*targ,**karg):
		cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		results=[];
		for ck in cks:
			results.append(self.conn[self.tname][ck].find(*targ,**karg));
		results=tuple(results);
		return itertools.chain(*results);
	def findAll_v1(self,*targ,**karg):
		cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		for ck in cks:
			r=self.conn[self.tname][ck].find(*targ,**karg);
			for n in r:
				yield n;	
	def count(self):
		cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		results=[];
		for ck in cks:
			results.append(self.conn[self.tname][ck].count());
		return sum(results);
	def update(self,key,*targ,**karg):
		s=key_hash(key)%self.hashsize;
		chunk_name=self.prefix+str(s);
		return self.conn[self.tname][chunk_name].update(*targ,**karg);
	def remove(self,key,*targ,**karg):
		s=key_hash(key)%self.hashsize;
		chunk_name=self.prefix+str(s);
		return self.conn[self.tname][chunk_name].remove(*targ,**karg);
	def removeAll(self,*targ,**karg):
		cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		for ck in cks:
			r=self.conn[self.tname][ck].remove(*targ,**karg);
	def create_index(self,*targ,**karg):
		#cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		#for ck in cks:
		#	self.conn[self.tname][ck].create_index(*targ,**karg);
		for i in range(self.hashsize):
			n=self.prefix+str(i);
			self.conn[self.tname][n].ensure_index(*targ,**karg);

	def build_index (self,cname,*targ,**karg):
		if cname:
			self.conn[self.tname][cname].ensure_index(*targ,**karg);
		else:
			self.create_index(*targ,**karg)

	def drop(self):
		print self.tname;
		return self.conn.drop_database(self.tname);
	def hash_stats(self):
		cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		results=[];
		for ck in cks:
			results.append(self.conn[self.tname][ck].count());
		su=sum(results);
		avg=su*1.0/self.hashsize;
		k=0;
		for r in results:
			k+=(r-avg)**2;
		return math.sqrt(k/self.hashsize);	
	def entroy(self):
		cks=[ x for x in self.conn[self.tname].collection_names() if x.startswith(self.prefix)];
		results=[]
		for i in range(self.hashsize):
			n=self.prefix+str(i);
			c=0;
			if n in cks:
				c=self.conn[self.tname][n].count()		
			if c==0:
				c=1;	
			results.append(c);
		total=sum(results);
		if total<1:
			return 0.0
		re=0;
		for i in range(len(results)):
			results[i]=results[i]*1.0/total;
			re+=results[i]*math.log(results[i],2);
		n=math.log(1.0/self.hashsize,2);
		return 	math.fabs(n-re)/math.fabs(n);
			
		
	def disconnect(self):
		self.conn.disconnect();
if __name__=="__main__":
	c=Connection("127.0.0.1",27017,"minimap",True,100,"admin","lse");
	#v=c.find("0ca779571631f8b68176502002cfb488",{"id":"0ca779571631f8b68176502002cfb488"});
	#for r in v:
	#	print r
	#print c.hash_stats();
	#cc=pymongo.Connection("172.17.110.33",27017);
	#cc["Release_dianping"].authenticate("jophiel","lse");
	#r=cc["Release_dianping"]["release_v2.0.0.3.24"].find();
	#for i in r:
	#	del i["_id"];
	#	c.insert(i["key"],i);
	
	#c.create_index("key");
	#t=c.findAll_v1();
	#for n in t:
	#	print n;
	#cc.disconnect();
	print c.count();
	print c.hash_stats();
	print c.entroy();
	#print c.drop();
	c.disconnect();
